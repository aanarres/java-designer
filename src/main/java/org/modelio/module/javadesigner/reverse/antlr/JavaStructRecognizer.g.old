/** old Java 1.7 Recognizer used for internal structural analysis
 * Useless since the conversion to ANTLR3
 *
 * Run 'java Main [-showtree] directory-full-of-java-files'
 *
 * [The -showtree option pops up a Swing frame that shows
 *  the Tree constructed from the parser.]
 *
 * Run 'java Main <directory full of java files>'
 *
 * Contributing authors:
 *		John Mitchell		johnm@non.net
 *		Terence Parr		parrt@magelang.com
 *		John Lilley			jlilley@empathy.com
 *		Scott Stanchfield	thetick@magelang.com
 *		Markus Mohnen       mohnen@informatik.rwth-aachen.de
 *      Peter Williams      pete.williams@sun.com
 *      Allan Jacobs        Allan.Jacobs@eng.sun.com
 *      Steve Messick       messick@redhills.com
 *      John Pybus			john@pybus.org
 *
 * Version 1.00 December 9, 1997 -- initial release
 * Version 1.01 December 10, 1997
 *		fixed bug in octal def (0..7 not 0..8)
 * Version 1.10 August 1998 (parrt)
 *		added tree construction
 *		fixed definition of WS,comments for mac,pc,unix newlines
 *		added unary plus
 * Version 1.11 (Nov 20, 1998)
 *		Added 'shutup' option to turn off last ambig warning.
 *		Fixed inner  def to allow named class defs as statements
 *		synchronized requires compound not simple statement
 *		add [] after builtInType DOT class in primaryExpression
 *		'const' is reserved but not valid..removed from modifiers
 * Version 1.12 (Feb 2, 1999)
 *		Changed LITERAL_xxx to xxx in tree grammar.
 *		Updated java.g to use tokens {...} now for 2.6.0 (new feature).
 *
 * Version 1.13 (Apr 23, 1999)
 *		Didn't have (stat)? for else clause in tree parser.
 *		Didn't gen ASTs for interface extends.  Updated tree parser too.
 *		Updated to 2.6.0.
 * Version 1.14 (Jun 20, 1999)
 *		Allowed final/abstract on local classes.
 *		Removed local interfaces from methods
 *		Put instanceof precedence where it belongs...in relationalExpr
 *			It also had expr not type as arg; fixed it.
 *		Missing ! on SEMI in classBlock
 *		fixed: (expr) + 'string' was parsed incorrectly (+ as unary plus).
 *		fixed: didn't like Object[].class in parser or tree parser
 * Version 1.15 (Jun 26, 1999)
 *		Screwed up rule with instanceof in it. :(  Fixed.
 *		Tree parser didn't like (expr).something; fixed.
 *		Allowed multiple inheritance in tree grammar. oops.
 * Version 1.16 (August 22, 1999)
 *		Extending an interface built a wacky tree: had extra EXTENDS.
 *		Tree grammar didn't allow multiple superinterfaces.
 *		Tree grammar didn't allow empty var initializer: {}
 * Version 1.17 (October 12, 1999)
 *		ESC lexer rule allowed 399 max not 377 max.
 *		java.tree.g didn't handle the expression of synchronized
 *		statements.
 * Version 1.18 (August 12, 2001)
 *      	Terence updated to Java 2 Version 1.3 by
 *		observing/combining work of Allan Jacobs and Steve
 *		Messick.  Handles 1.3 src.  Summary:
 *		o  primary didn't include boolean.class kind of thing
 *      	o  constructor calls parsed explicitly now:
 * 		   see explicitConstructorInvocation
 *		o  add strictfp modifier
 *      	o  missing objBlock after new expression in tree grammar
 *		o  merged local class definition alternatives, moved after declaration
 *		o  fixed problem with ClassName.super.field
 *      	o  reordered some alternatives to make things more efficient
 *		o  long and double constants were not differentiated from int/float
 *		o  whitespace rule was inefficient: matched only one char
 *		o  add an examples directory with some nasty 1.3 cases
 *		o  made Main.java use buffered IO and a Reader for Unicode support
 *		o  supports UNICODE?
 *		   Using Unicode charVocabulay makes code file big, but only
 *		   in the bitsets at the end. I need to make ANTLR generate
 *		   unicode bitsets more efficiently.
 * Version 1.19 (April 25, 2002)
 *		Terence added in nice fixes by John Pybus concerning floating
 *		constants and problems with super() calls.  John did a nice
 *		reorg of the primary/postfix expression stuff to read better
 *		and makes f.g.super() parse properly (it was METHOD_CALL not
 *		a SUPER_CTOR_CALL).  Also:
 *
 *		o  'finally' clause was a root...made it a child of 'try'
 *		o  Added stuff for asserts too for Java 1.4, but *commented out*
 *		   as it is not backward compatible.
 *
 * Version 1.20 (October 27, 2002)
 *
 *      Terence ended up reorging John Pybus' stuff to
 *      remove some nondeterminisms and some syntactic predicates.
 *      Note that the grammar is stricter now; e.g., this(...) must
 *	be the first statement.
 *
 *      Trinary ?: operator wasn't working as array name:
 *          (isBig ? bigDigits : digits)[i];
 *
 *      Checked parser/tree parser on source for
 *          Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4,
 *	    and the 110k-line jGuru server source.
 *
 * This grammar is in the PUBLIC DOMAIN
 */
grammar JavaStructRecognizer;

options {
  output = AST;
  backtrack = true;
  memoize = true;
  ASTLabelType=ASTTree;   // type of AST nodes id ASTTree
}


tokens {
  BLOCK; MODIFIERS; OBJBLOCK; SLIST; CTOR_DEF; METHOD_DEF; VARIABLE_DEF;
  INSTANCE_INIT; STATIC_INIT; TYPE; CLASS_DEF; INTERFACE_DEF;
  PACKAGE_DEF; ARRAY_DECLARATOR; EXTENDS_CLAUSE; IMPLEMENTS_CLAUSE;
  PARAMETERS; PARAMETER_DEF; LABELED_STAT; TYPECAST; INDEX_OP;
  POST_INC; POST_DEC; METHOD_CALL; EXPR; ARRAY_INIT;
  IMPORT; UNARY_MINUS; UNARY_PLUS; CASE_GROUP; ELIST; FOR_INIT; FOR_CONDITION;
  FOR_ITERATOR; EMPTY_STAT; FINAL='final'; ABSTRACT='abstract';
  STRICTFP='strictfp'; SUPER_CTOR_CALL; CTOR_CALL; JAVADOC_COMMENT; COMMENT; COMMENTS;
  TYPE_ARGS; TYPE_ARGS_END; TYPE_PARAMS;  WILDCARD; TYPE_TYPE_PARAMS; TYPE_ARGUMENTS; 
  TYPE_ARGUMENT;
  ENUM; ENUM_DEF; ENUM_CONST; ENUM_CONST_INIT;
  ANNOTATION_DEF; ANNOTATION_MEMBER_DEF; ANNOTATION; ANNOTATIONS;
  ANNOTATION_INIT_EMPTY; ANNOTATION_INIT_VALUE; ANNOTATION_INIT_LIST;
  ANNOTATION_INIT_MEMBER; ANNOTATION_ARRAY_INIT;
  SR_ASSIGN; BSR_ASSIGN; GE; SL_ASSIGN; LE; SL; SR;
  }

@header {
   package com.modeliosoft.modelio.javadesigner.reverse.antlr.struct;
   import com.modeliosoft.modelio.javadesigner.reverse.antlr.ASTTree;
}

@members {
  
//  @Override
//  public String getErrorMessage(RecognitionException e, String[] tokenNames) {
//     return super.getErrorMessage(e, tokenNames);
//  }
}

/* @rulecatch { }  // previously  options { defaultErrorHandler = false} */

/* Declarations for the lexer */

@lexer::header {
   package com.modeliosoft.modelio.javadesigner.reverse.antlr.struct;
}

@lexer::members {
//  @Override
//  public String getErrorMessage(RecognitionException e, String[] tokenNames) {
//     return super.getErrorMessage(e, tokenNames);
//  }
}

/* End of lexer declarations */


// Compilation Unit: In Java, this is a single file.  This is the start
//   rule for this parser
compilationUnit
  :     
   packageDefinition? importDefinition* typeDefinition+
  ;


// JPE java 1.5 : definition des annotations
// Definition of an annotation type (JSR 175)
annotationTypeDefinition[Object dum1, Object dum2]
	:	modifiers AT 'interface' IDENT
		// now parse the body of the annotation type
		ab=annotationBlock
//		{$annotationTypeDefinition = $($[ANNOTATION_DEF,'ANNOTATION_DEF'],
//									modifiers,IDENT,ab);}
    -> ^(ANNOTATION_DEF modifiers IDENT $ab)
	;

// This is the body of an annotation type. Only inner type definitions and
// members (which use a notation similar to methods) are allowed.
annotationBlock
	:	LCURLY
			( annotationField | SEMI )*
		RCURLY
		// {$annotationBlock = $([OBJBLOCK, 'OBJBLOCK'], $annotationBlock);}
		-> ^(OBJBLOCK annotationField*)
	;
	
//annotationField!
//  :
//    j:javadocDefinitions a:annotations mods:modifiers 
//    ( it:innerTypeDef[#mods, #j, #a]    // inner type definition
//      {#annotationField = #it;}
//    | ts:typeSpec[false] tp:typeTypeParameters!
//      ( i:IDENT LPAREN RPAREN dv:defaultValue SEMI
//        {#annotationField =
//            #(#[ANNOTATION_MEMBER_DEF,"ANNOTATION_MEMBER_DEF"],
//            mods, #(#[TYPE,"TYPE"],ts), i, dv); }
//      | v:variableDefinitions[#mods,#ts, #j, #a] SEMI
//        {#annotationField = #v;}
//      )
//    ) 
//  ;
	
annotationField
	:
		a=annotations mods=modifiers 
		(	it=innerTypeDef[$mods.tree, $a.tree]
		  -> $it	// inner type definition
		|	ts=typeSpec[false] tp=typeTypeParameters
			(	i=IDENT LPAREN RPAREN dv=defaultValue SEMI
			  -> ^(ANNOTATION_MEMBER_DEF $mods ^(TYPE $ts) $i $dv?)
			|	v=variableDefinitions[$mods.tree, $ts.tree, $a.tree] SEMI
			  -> $v
			)
		) 
	;

// Fields that are type definitions.
//protected
//innerTypeDef![AST modifiers, AST comment, AST annotation]
//  :   ( ed:enumDefinition[modifiers,comment, annotation]        // inner enum
//      {#innerTypeDef = #ed;}
//
//    | cd:classDefinition[modifiers,comment, annotation]       // inner class
//      {#innerTypeDef = #cd;}
//
//    | id:interfaceDefinition[modifiers,comment, annotation]   // inner interface
//      {#innerTypeDef = #id;}
//
//    | ad:annotationTypeDefinition[modifiers,comment, annotation]   // inner annotation type
//      {#innerTypeDef = #ad;}
//    )
//    ; 
innerTypeDef[Object modifiers, Object annotation]
	: (	ed=enumDefinition[modifiers, annotation]        // inner enum
		|	cd=classDefinition[modifiers, annotation]       // inner class
		|	id=interfaceDefinition[modifiers, annotation]   // inner interface
		|	ad=annotationTypeDefinition[modifiers, annotation]   // inner annotation type
		)
		; 
 
// Annotation members may have optional default values.
defaultValue
	:	( 'default'^ annotationMemberValue )?
	;

annotations
	:	annotation*
		// {$annotations = $([ANNOTATIONS, 'ANNOTATIONS'], $annotations);}
		-> ^(ANNOTATIONS annotation*)
	;

annotation
	:	at=AT identifier annotationInit
		-> ^(ANNOTATION[$at] identifier annotationInit) 
	;

// The initialization (list of assignments, single value, or nothing).
annotationInit
  : ( lp=LPAREN
      ( annotationMemberInit (COMMA annotationMemberInit)* -> ^(ANNOTATION_INIT_LIST[$lp] annotationMemberInit*)
      | annotationMemberValue                              -> ^(ANNOTATION_INIT_VALUE[$lp] annotationMemberValue)
      |                                                    -> ^(ANNOTATION_INIT_EMPTY[$lp])
      )
      RPAREN
    )
  |  -> ^(ANNOTATION_INIT_EMPTY)
  ;

//annotationMemberInit
//  : IDENT ASSIGN! annotationMemberValue
//    {#annotationMemberInit =
//     #([ANNOTATION_INIT_MEMBER, "AN_INIT_MEMBER"], #annotationMemberInit);}
//  ;
annotationMemberInit
	:	IDENT ASSIGN annotationMemberValue
    -> ^(ANNOTATION_INIT_MEMBER IDENT annotationMemberValue)
	;

annotationMemberValue
	:	annotation
	|	conditionalExpression
		// {$annotationMemberValue = $($[EXPR,'EXPR'],$annotationMemberValue);}
		-> ^(EXPR conditionalExpression)
	|	annotationMemberArrayInitializer
	;

// This is an initializer used to set up an array as an annotation member
// value.
annotationMemberArrayInitializer
	:	lc=LCURLY // {$lc.setType(ANNOTATION_ARRAY_INIT);}	             
			(annotationMemberValue (COMMA annotationMemberValue)* )?
			COMMA?
		RCURLY
		-> ^(ANNOTATION_ARRAY_INIT[$lc] annotationMemberValue*)
	;

// end JAva 1.5 annotations
//enumDefinition![AST modifiers, AST comments, AST annotation]
//  : "enum" IDENT
//    // it might implement some interfaces...
//    ic:implementsClause
//    // now parse the body of the enum
//    eb:enumBlock 
//    {#enumDefinition = #(#[ENUM_DEF,"ENUM_DEF"], modifiers,IDENT,ic,annotation,eb);}
//  ;
enumDefinition[Object modifiers, Object annotation]
	:	'enum' id=IDENT
		// it might implement some interfaces...
		ic=implementsClause
		// now parse the body of the enum
		eb=enumBlock
		-> ^(ENUM_DEF {$modifiers} $id $ic {$annotation} $eb) 
	;

// This is the body of an enumeration.  It can contain a list of comma
// separated identifiers (the enum values), and optionally, seperated by a
// semicolon, some declarations like in a class at the end.
// The values of the enumeration may be annotated.
enumBlock
	:	LCURLY
			( enumConst (COMMA enumConst)* )?
			COMMA?	// optional comma at end of value list
			( SEMI ( 
			    ( field) 
			    | SEMI )* )?
		RCURLY
		// {$enumBlock = $([OBJBLOCK, 'OBJBLOCK'], $enumBlock);}
		-> ^(OBJBLOCK enumConst* field*)
	;

// Each enum value is in fact a class instance, and can be followed by the
// usual class declarations.
enumConst
	:	annotations IDENT enumConstInit classBlock?
		// {$enumConst = $([ENUM_CONST, 'ENUM_CONST'], $enumConst);}
		-> ^(ENUM_CONST  annotations IDENT enumConstInit classBlock?)
	;

// This is really a constructor invocation.
//enumConstInit
//	:	lp=LPAREN^ argList RPAREN! { $lp.setType(ENUM_CONST_INIT); }
//	|	{$enumConstInit = $([ENUM_CONST_INIT, ''], $enumConstInit);}
//	;
enumConstInit
  : (LPAREN argList RPAREN
  |)
  -> ^(ENUM_CONST_INIT argList?)
  ;

// Package statement: 'package' followed by an identifier.
//packageDefinition
//	options {defaultErrorHandler = true;} // let ANTLR handle errors */
//	:	ann=annotations! p='package'^ {$p.setType(PACKAGE_DEF);} identifier SEMI!
//	;

packageDefinition
  : annotations p='package' identifier SEMI
  -> ^(PACKAGE_DEF[$p] identifier)
  ;


// Import statement: import followed by a package or class name
//importDefinition
//  /* options {defaultErrorHandler = true;} */
//  : i='import'^ {$i.setType(IMPORT);} ('static')? identifierStar SEMI!
//  ;
importDefinition
  : i='import' st='static'? identifierStar SEMI
  -> ^(IMPORT[$i] $st? identifierStar)
  ;

// A type definition in a file is either a class or interface definition.
//typeDefinition[Object j]
//  /* options {defaultErrorHandler = true;} */
//  : a=annotations! m=modifiers!
//    ( classDefinition[$m,$j, $a]
//    | interfaceDefinition[$m,$j, $a]
//    | annotationTypeDefinition[$m,$j, $a]
//    | enumDefinition [$m,$j, $a]
//    )
//  | SEMI!
//  ;
typeDefinition
  : a=annotations! m=modifiers!
    ( classDefinition[$m.tree, $a.tree]
    | interfaceDefinition[$m.tree, $a.tree]
    | annotationTypeDefinition[$m.tree, $a.tree]
    | enumDefinition[$m.tree, $a.tree]
    )
  | SEMI!
  ;

// Les commentaires et les javadoc.
//javadocDefinitions
//  : javadocDefinition*
//    {$javadocDefinitions = $([COMMENTS, 'COMMENTS'], $javadocDefinitions);}
//  ;
//javadocDefinitions
//  : javadocDefinition*
//    -> ^(COMMENTS javadocDefinition*)
//  ;
	
//javadocDefinition
//	: 
//	   JAVADOC_COMMENT^
//	 | COMMENT^
//	;

/** A declaration is the creation of a reference or primitive-type variable
 *  Create a separate Type/Var tree for each var in the var list.
 */
//declaration!
//	:	j=javadocDefinitions a=annotations m=modifiers t=typeSpec[false]  v=variableDefinitions[$m,$t,$j, $a]
//		{$declaration = $v;}
//	;
declaration
  : a=annotations m=modifiers t=typeSpec[false] v=variableDefinitions[$m.tree, $t.tree, $a.tree]
    -> $v
  ;

// A type specification is a type name with possible brackets afterwards
//   (which would make it an array type).
typeSpec[boolean addImagNode]
	: classTypeSpec[addImagNode]
	| builtInTypeSpec[addImagNode]
	;

// A class type specification is a class type with possible brackets afterwards
//   (which would make it an array type).

//classTypeSpec[boolean addImagNode]
//	:	identifier typeArguments (lb=LBRACK^ {$lb.setType(ARRAY_DECLARATOR);} RBRACK!)*
//		{
//			if ( addImagNode ) {
//				$classTypeSpec = $($[TYPE,'TYPE'], $classTypeSpec);
//			}
//		}
//	;
	
classTypeSpec[boolean addImagNode]
  : ( identifier typeArguments -> identifier typeArguments )
    ( lb=LBRACK RBRACK -> ^(ARRAY_DECLARATOR[$lb] $classTypeSpec) )*
     ->  {addImagNode}? ^(TYPE $classTypeSpec)
     ->                 $classTypeSpec
  ;

// A builtin type specification is a builtin type with possible brackets
// afterwards (which would make it an array type).
//builtInTypeSpec[boolean addImagNode]
//	:	builtInType (lb=LBRACK^ {$lb.setType(ARRAY_DECLARATOR);} RBRACK!)*
//		{
//			if ( addImagNode ) {
//				$builtInTypeSpec = $($[TYPE,'TYPE'], $builtInTypeSpec);
//			}
//		}
//	;
builtInTypeSpec[boolean addImagNode]
  : ( builtInType -> builtInType)
    ( lb=LBRACK RBRACK -> ^(ARRAY_DECLARATOR[$lb] $builtInTypeSpec) )*
     ->  {addImagNode}? ^(TYPE $builtInTypeSpec)
     ->                 $builtInTypeSpec
  ;


// A type name. which is either a (possibly qualified) class name or
//   a primitive (builtin) type
type
	:	identifier
	|	builtInType
	;

// The primitive types.
builtInType
	:	'void'
	|	'boolean'
	|	'byte'
	|	'char'
	|	'short'
	|	'int'
	|	'float'
	|	'long'
	|	'double'
	;

// A (possibly-qualified) java identifier.  We start with the first IDENT
//   and expand its name by adding dots and following IDENTS
identifier
	:	IDENT  ( DOT^ IDENT )*
	;

identifierStar
	:	IDENT
		( DOT^ IDENT )*
		( DOT^ STAR  )?
	;

// A list of zero or more modifiers.  We could have used (modifier)* in
//   place of a call to modifiers, but I thought it was a good idea to keep
//   this rule separate so they can easily be collected in a Vector if
//   someone so desires
//modifiers
//	:	( modifier )*
//		{$modifiers = $([MODIFIERS, 'MODIFIERS'], $modifiers);}
//	;
modifiers
  : modifier*
  -> ^(MODIFIERS modifier*)
  ;

// modifiers for Java classes, interfaces, class/instance vars and methods
modifier
	:	'private'
	|	'public'
	|	'protected'
	|	'static'
	|	'transient'
	|	'final'
	|	'abstract'
	|	'native'
	|	'threadsafe'
	|	'synchronized'
//	|	'const'			// reserved word, but not valid
	|	'volatile'
	|	'strictfp'
	;

// Definition of a Java class
//classDefinition![Object modifiers, Object javadocDefinitions, Object annotation]
//	:	'class' IDENT
//		// types parameters for generics
//	    tp=typeTypeParameters
//		// it _might_ have a superclass...
//		sc=superClassClause
//		// it might implement some interfaces...
//		ic=implementsClause
//		// now parse the body of the class
//		cb=classBlock
//		{$classDefinition = $($[CLASS_DEF,'CLASS_DEF'],
//							   modifiers,IDENT,javadocDefinitions,tp, cb);}
//	;
classDefinition[Object modifiers, Object annotation]
  : 'class' id=IDENT
    // types parameters for generics
      tp=typeTypeParameters
    // it _might_ have a superclass...
    sc=superClassClause
    // it might implement some interfaces...
    ic=implementsClause
    // now parse the body of the class
    cb=classBlock
    -> ^(CLASS_DEF {$modifiers} $id $tp $cb)
  ;

// Rules added by JPE for java5
//typeTypeParameters
//	:
//		(
//			lt=LT^	{ $lt.setType(TYPE_TYPE_PARAMS); }
//			typeParameter (COMMA! typeParameter)*
//      gt=GT!  { $gt.setType(TYPE_ARGS_END);}
//		)
//	|	{$typeTypeParameters = $($[TYPE_TYPE_PARAMS,'TYPE_TYPE_PARAMS'], $typeTypeParameters);}
//	; 
typeTypeParameters
  :
    (  
      lt=LT typeParameter (COMMA typeParameter)* GT
    ) -> ^(TYPE_TYPE_PARAMS[$lt] typeParameter+)
  |   -> ^(TYPE_TYPE_PARAMS)
  ; 
	 
//operationTypeParameters
//	:
//		(
//			lt=LT^	{ $lt.setType(TYPE_PARAMS); }
//			typeParameter (COMMA! typeParameter)*
//      gt=GT!  { $gt.setType(TYPE_ARGS_END);}
//		)
//	|	{$operationTypeParameters = $($[TYPE_PARAMS,'TYPE_PARAMS'], $operationTypeParameters);}
//	; 
operationTypeParameters
  :
    (
      lt=LT typeParameter (COMMA typeParameter)* GT
    ) -> ^(TYPE_PARAMS[$lt] typeParameter+)
  |   -> ^(TYPE_TYPE_PARAMS)
  ; 
	
typeParameter
	:	IDENT
		( 'extends' classOrInterfaceType[true]
			(BAND! classOrInterfaceType[true])*
		)?
	;

//typeArguments
//	:
//	(
//	  lt=LT^	{ $lt.setType(TYPE_ARGS); }
//	  (typeArgument)?
//	  (COMMA! typeArgument)*
//	  gt=GT! {$gt.setType(TYPE_ARGS_END);}
//	)
//  | {$typeArguments = $($[TYPE_ARGS,'TYPE_ARGS'], $typeArguments);}
//	;
typeArguments
  :
  (
    LT typeArgument? (COMMA typeArgument)* GT
  ) -> ^(TYPE_ARGS typeArgument*)
  | -> ^(TYPE_ARGS)
  ;

//// either reference type or wildcard type with optional lower or upper bound
//typeArgument!
//	:	(	q=QUESTION^ {$q.setType(WILDCARD);}
//			( // faux conflict on 'extends' because typeArgsEnd may be empty
//				options{greedy=true;}:
//				'extends' referenceTypeSpec[true]
//			|	'super' referenceTypeSpec[true]
//			)?
//		)
//	|	rts=referenceTypeSpec[true]
//           {$typeArgument = $($[TYPE_ARGUMENT, 'TYPE_ARGUMENT'], rts);}
//	;
// either reference type or wildcard type with optional lower or upper bound
typeArgument
  : ( q=QUESTION
      (
        e='extends' referenceTypeSpec[true]
      | s='super' referenceTypeSpec[true]
      )?
    ) -> ^(WILDCARD[$q] $e? $s? referenceTypeSpec?)
  | rts=referenceTypeSpec[true] 
    -> ^(TYPE_ARGUMENT $rts)
  ;

//classOrInterfaceType[boolean addImagNode]
//	:	IDENT typeArguments
//		(options{greedy=true;}: // match as many as possible
//			DOT^
//			IDENT typeArguments
//		)*
//		{
//			if ( addImagNode ) {
//				$classOrInterfaceType = $($[TYPE,'TYPE'],
//					$classOrInterfaceType);
//			}
//		}
//	;
classOrInterfaceType[boolean addImagNode]
  : (IDENT typeArguments -> IDENT typeArguments)
    (options{greedy=true;}: // match as many as possible
      d=DOT
      IDENT typeArguments -> ^(DOT[$d] $classOrInterfaceType IDENT typeArguments)
    )*
    -> {addImagNode}? ^(TYPE $classOrInterfaceType)
    -> $classOrInterfaceType
  ;
	
referenceTypeSpec[boolean addImagNode]
	: classTypeSpec[addImagNode]
	| arrayTypeSpec[addImagNode]
	;
	
	// An array type specification is a builtin type with brackets afterwards
//arrayTypeSpec[boolean addImagNode]
//	:	builtInType
//		(options{greedy=true;}: // match as many as possible
//			lb=LBRACK^ {$lb.setType(ARRAY_DECLARATOR);} RBRACK!
//		)+
//		{
//			if ( addImagNode ) {
//				$arrayTypeSpec = $($[TYPE,'TYPE'], $arrayTypeSpec);
//			}
//		}
//	;
arrayTypeSpec[boolean addImagNode]
  : ( builtInType -> builtInType )
    ( lb=LBRACK RBRACK -> ^(ARRAY_DECLARATOR[$lb] $arrayTypeSpec) )*
     ->  {addImagNode}? ^(TYPE $arrayTypeSpec)
     ->                 $arrayTypeSpec
  ;

//superClassClause!
//  : ( 'extends' id=classOrInterfaceType[false] )?
//    {$superClassClause = $($[EXTENDS_CLAUSE,'EXTENDS_CLAUSE'],id);}
//  ;
superClassClause
  : ( 'extends' id=classOrInterfaceType[false] )?
  -> ^(EXTENDS_CLAUSE $id?)
  ;

//// Definition of a Java Interface
//interfaceDefinition![Object modifiers, Object javadocDefinitions, Object annotation]
//	:	'interface' IDENT
//		// java 1.5 : generics
//		tp=typeTypeParameters
//		// it might extend some other interfaces
//		ie=interfaceExtends
//		// now parse the body of the interface (looks like a class...)
//		cb=classBlock
//		{$interfaceDefinition = $($[INTERFACE_DEF,'INTERFACE_DEF'],
//									IDENT,modifiers,javadocDefinitions,tp,cb);}
//	;
// Definition of a Java Interface
interfaceDefinition[Object modifiers, Object annotation]
  : 'interface' id=IDENT
    // java 1.5 : generics
    tp=typeTypeParameters
    // it might extend some other interfaces
    interfaceExtends
    // now parse the body of the interface (looks like a class...)
    cb=classBlock
    -> ^(INTERFACE_DEF $id {$modifiers} $tp $cb)
  ;


// This is the body of a class.  You can have fields and extra semicolons,
// That's about it (until you see what a field is...)
//classBlock
//	:	LCURLY!
//			(j=javadocDefinitions! field[$j] | SEMI! )* 
//			javadocDefinitions
//		RCURLY!
//		{$classBlock = $([OBJBLOCK, 'OBJBLOCK'], $classBlock);}
//	;
classBlock
  : LCURLY
      (field | SEMI )* 
    RCURLY
    -> ^(OBJBLOCK field*)
  ;

// An interface can extend several other interfaces...
//interfaceExtends
//	:	(
//		e='extends'!
//		classOrInterfaceType[false] ( COMMA! classOrInterfaceType[false] )*
//		)?
//		{$interfaceExtends = $($[EXTENDS_CLAUSE,'EXTENDS_CLAUSE'],
//							$interfaceExtends);}
//	;
interfaceExtends
  : (
      'extends'
      classOrInterfaceType[false] ( COMMA classOrInterfaceType[false] )*
    )?
    -> ^(EXTENDS_CLAUSE classOrInterfaceType*)
  ;

// A class can implement several interfaces...
//implementsClause
//	:	(
//			i='implements'! classOrInterfaceType[false] ( COMMA! classOrInterfaceType[false] )*
//		)?
//		{$implementsClause = $($[IMPLEMENTS_CLAUSE,'IMPLEMENTS_CLAUSE'],
//								 $implementsClause);}
//	;
implementsClause
  : (
      'implements'
      classOrInterfaceType[false] ( COMMA classOrInterfaceType[false] )*
    )?
    -> ^(IMPLEMENTS_CLAUSE classOrInterfaceType*)
  ;

// Now the various things that can be defined inside a class or interface...
// Note that not all of these are really valid in an interface (constructors,
//   for example), and if this grammar were used for a compiler there would
//   need to be some semantic checks to make sure we're doing the right thing...
//field![Object j]
//	:	// method, constructor, or variable declaration
//	ann=annotations mods=modifiers
//		(	h=ctorHead s=constructorBody // constructor
//			{$field = $($[CTOR_DEF,'CTOR_DEF'], j, mods, h, s);}
//
//		|	cd=classDefinition[$mods, $j, $ann]       // inner class
//			{$field = $cd;}
//
//		|	id=interfaceDefinition[$mods, $j, $ann]   // inner interface
//			{$field = $id;}
//
//		|	ed=enumDefinition[$mods, $j, $ann]   // inner enumeration
//			{$field = $ed;}	
//		|	ad=annotationTypeDefinition[$mods, $j, $ann]   // inner annotation definition
//			{$field = $ad;}						
//			
//		|	tp=operationTypeParameters // java 1.5 : generic methods
//		    t=typeSpec[false]  // method or variable declaration(s)
//			(	IDENT  // the name of the method
//
//				// parse the formal parameter declarations.
//				LPAREN! param=parameterDeclarationList RPAREN!
//				rt=declaratorBrackets[$t]
//
//				// get the list of exceptions that this method is
//				// declared to throw
//				(tc=throwsClause)?
//
//				( s2=compoundStatement | SEMI )
//				/*{isBody = true;
//				$field = $($[METHOD_DEF,'METHOD_DEF'],
//							 tp,
//						     mods,
//							 $($[TYPE,'TYPE'],rt),
//							 IDENT,
//							 j,
//							 param,
//							 tc,
//							 s2);}*/
//				{$field = $($[METHOD_DEF,'METHOD_DEF'],
//							 tp,
//							 IDENT
//							);
//							 }
//			|	v=variableDefinitions[$mods,$t,$j, $ann] SEMI
////				{$field = $($[VARIABLE_DEF,'VARIABLE_DEF'], v);}
//				//{$field = $v;}
//			)
//		)
//
//    // 'static { ... }' class initializer
//	|	'static' s3=compoundStatement
//		//{$field = $($[STATIC_INIT,'STATIC_INIT'], j, s3);}
//
//    // '{ ... }' instance initializer
//	|	s4=compoundStatement
//		//{$field = $($[INSTANCE_INIT,'INSTANCE_INIT'], j, s4);}
//	;
field
  : // method, constructor, or variable declaration
  ann=annotations mods=modifiers
    ( h=ctorHead s=constructorBody // constructor
      -> ^(CTOR_DEF $mods $h $s)

    | cd=classDefinition[$mods.tree, $ann.tree]       // inner class
      -> $cd

    | id=interfaceDefinition[$mods.tree, $ann.tree]   // inner interface
      -> $id

    | ed=enumDefinition[$mods.tree, $ann.tree]   // inner enumeration
      -> $ed
    | ad=annotationTypeDefinition[$mods.tree, $ann.tree]   // inner annotation definition
      -> $ad      
    | tp=operationTypeParameters // java 1.5 : generic methods
        t=typeSpec[false]  // method or variable declaration(s)
      ( ident=IDENT  // the name of the method

        // parse the formal parameter declarations.
        LPAREN param=parameterDeclarationList RPAREN
        rt=declaratorBrackets[$t.tree]

        // get the list of exceptions that this method is
        // declared to throw
        (tc=throwsClause)?

        ( s2=compoundStatement | SEMI )
        -> ^(METHOD_DEF $tp $ident)
      | v=variableDefinitions[$mods.tree, $t.tree, $ann.tree] SEMI
        -> ^(VARIABLE_DEF $v)
      )
    )

    // 'static { ... }' class initializer
  | 'static' s3=compoundStatement
    -> ^(STATIC_INIT $s3)

    // '{ ... }' instance initializer
  | s4=compoundStatement
    -> ^(INSTANCE_INIT $s4)
  ;

//constructorBody
//    :   lc=LCURLY^ {$lc.setType(SLIST);}
//            ( options { greedy=true; } : explicitConstructorInvocation)?
//            (statement)*
//        RCURLY!
//    ;
constructorBody
    :   lc=LCURLY
            ( options { greedy=true; } : explicitConstructorInvocation)?
            statement*
        RCURLY
    -> ^(SLIST explicitConstructorInvocation? statement*)
    ;

/** Catch obvious constructor calls, but not the expr.super(...) calls */
//explicitConstructorInvocation
//    :   'this'! lp1=LPAREN^ argList RPAREN! SEMI!
//		{$lp1.setType(CTOR_CALL);}
//    |   'super'! lp2=LPAREN^ argList RPAREN! SEMI!
//		{$lp2.setType(SUPER_CTOR_CALL);}
//    ;
explicitConstructorInvocation
    :  'this' lp1=LPAREN argList RPAREN SEMI -> ^(CTOR_CALL argList)
    |  'super' lp2=LPAREN argList RPAREN SEMI -> ^(SUPER_CTOR_CALL argList)
    ;

//variableDefinitions[Object mods, Object t, Object javadocs, Object ann]
//	:	variableDeclarator[getASTFactory().dupTree(mods),
//						   getASTFactory().dupTree(t), getASTFactory().dupTree(javadocs)]
//		(	COMMA^ 
//			 variableDeclarator[getASTFactory().dupTree(mods),
//							   getASTFactory().dupTree(t), getASTFactory().dupTree(javadocs)]
//		)* 
//	;
variableDefinitions[Object mods, Object t, Object ann]
  : variableDeclarator[mods, t]
    ( COMMA^ 
       variableDeclarator[mods, t]
    )* 
  ;

/** Declaration of a variable.  This can be a class/instance variable,
 *   or a local variable in a method
 * It can also include possible initialization.
 */
//variableDeclarator![Object mods, Object t, Object javadocs]
//	:	id=IDENT tp=typeArguments d=declaratorBrackets[t] v=varInitializer
//		{$variableDeclarator = $($[VARIABLE_DEF,'VARIABLE_DEF'], javadocs, mods, $($[TYPE,'TYPE'],d), id, $($[TYPE_ARGUMENTS, 'TYPE_ARGUMENTS'], tp), v);}
//	;
variableDeclarator[Object mods, Object t]
  : id=IDENT tp=typeArguments d=declaratorBrackets[t] v=varInitializer
    -> ^(VARIABLE_DEF {$mods} ^(TYPE $d) $id ^(TYPE_ARGUMENTS $tp) $v?)
  ;

//declaratorBrackets[Object typ]
//  : {$declaratorBrackets=typ;}
//    (lb=LBRACK^ {$lb.setType(ARRAY_DECLARATOR);} RBRACK!)*
//  ;
declaratorBrackets[Object typ]
  : ( -> {$typ})
    (lb=LBRACK RBRACK -> ^(ARRAY_DECLARATOR $declaratorBrackets))*
  ;

varInitializer
	:	( ASSIGN^ initializer )?
	;

// This is an initializer used to set up an array.
//arrayInitializer
//	:	lc=LCURLY^ {$lc.setType(ARRAY_INIT);}
//			(	initializer
//				(
//					// CONFLICT: does a COMMA after an initializer start a new
//					//           initializer or start the option ',' at end?
//					//           ANTLR generates proper code by matching
//					//			 the comma as soon as possible.
//					options {
//						greedy = true;
//					}
//				:
//					COMMA! initializer
//				)*
//				(COMMA!)?
//			)?
//		RCURLY!
//	;
arrayInitializer
  : lc=LCURLY
      ( initializer
        (
          // CONFLICT: does a COMMA after an initializer start a new
          //           initializer or start the option ',' at end?
          //           ANTLR generates proper code by matching
          //       the comma as soon as possible.
          options {
            greedy = true;
          }
        :
          COMMA initializer
        )*
        COMMA?
      )?
    RCURLY
    -> ^(ARRAY_INIT[$lc] initializer* )
  ;


// The two 'things' that can initialize an array element are an expression
//   and another (nested) array initializer.
initializer
	:	expression
	|	arrayInitializer
	;

// This is the header of a method.  It includes the name and parameters
//   for the method.
//   This also watches for a list of exception classes in a 'throws' clause.
ctorHead
	:	IDENT  // the name of the method

		// parse the formal parameter declarations.
		LPAREN! parameterDeclarationList RPAREN!

		// get the list of exceptions that this method is declared to throw
		(throwsClause)?
	;

// This is a list of exception classes that the method is declared to throw
throwsClause
	:	'throws'^ identifier ( COMMA! identifier )*
	;


// A list of formal parameters
//parameterDeclarationList
//	:	( parameterDeclaration ( COMMA! parameterDeclaration )* )?
//		{$parameterDeclarationList = $($[PARAMETERS,'PARAMETERS'],
//									$parameterDeclarationList);}
//	;
parameterDeclarationList
  : ( parameterDeclaration ( COMMA parameterDeclaration )* )?
    -> ^(PARAMETERS parameterDeclaration*)
  ;

// A formal parameter.
// The ellipsis is the support for varargs (JSR 201)
// This rule allows ellipsis on any parameter, not just the last (as specified
// by JSR 201), so a semantic check is needed for that.
//parameterDeclaration!
//	:	ann1=annotations pm=parameterModifier ann2=annotations t=typeSpec[false] ( el=ELLIPSIS )? id=IDENT
//		pd=declaratorBrackets[$t]
//		{$parameterDeclaration = $($[PARAMETER_DEF,'PARAMETER_DEF'],
//									pm, ann1, ann2, $([TYPE,'TYPE'],pd), id);}
//	;
parameterDeclaration
  : ann1=annotations pm=parameterModifier ann2=annotations t=typeSpec[false] ( el=ELLIPSIS )? id=IDENT
    pd=declaratorBrackets[$t.tree]
    -> ^(PARAMETER_DEF
                  $pm $ann1 $ann2 ^(TYPE $pd) $id)
  ;

//parameterModifier
//  : (f='final')?
//    {$parameterModifier = $($[MODIFIERS,'MODIFIERS'], f);}
//  ;
parameterModifier
  : f='final'? -> ^(MODIFIERS $f?)
  ;

// Compound statement.  This is used in many contexts:
//   Inside a class definition prefixed with 'static':
//      it is a class initializer
//   Inside a class definition without 'static':
//      it is an instance initializer
//   As the body of a method
//   As a completely indepdent braced block of code inside a method
//      it starts a new scope for variable definitions

//compoundStatement
//  : lc=LCURLY^ {$lc.setType(SLIST);}
//      // include the (possibly-empty) list of statements
//      (statement)*
//    RCURLY!
//  ;
compoundStatement
	:	LCURLY
			// include the (possibly-empty) list of statements
			statement*
		RCURLY
		-> ^(SLIST statement*)
	;


//statement
//	// A list of statements in curly braces -- start a new scope!
//	:	compoundStatement
//	// declarations are ambiguous with 'ID DOT' relative to expression
//	// statements.  Must backtrack to be sure.  Could use a semantic
//	// predicate to test symbol table to see what the type was coming
//	// up, but that's pretty hard without a symbol table ;)
//	|	(declaration)=> declaration SEMI!
//
//	// An expression statement.  This could be a method call,
//	// assignment statement, or any other expression evaluated for
//	// side-effects.
//	|	expression SEMI!
//
//	// class definition
//	|	j=javadocDefinitions a=annotations! m=modifiers! classDefinition[$m, $j, $a]
//
//	// Attach a label to the front of a statement
//	|	IDENT c=COLON^ {$c.setType(LABELED_STAT);} statement
//
//	// If-else statement
//	|	'if'^ LPAREN! expression RPAREN! statement
//		(
//			// CONFLICT: the old 'dangling-else' problem...
//			//           ANTLR generates proper code matching
//			//			 as soon as possible.  Hush warning.
//			options {
//				greedy = true;
//			}
//		:
//			'else'! statement
//		)?
//
//	// For statement
//	|	'for'^
//			LPAREN!
//			(
//				( parameterDeclaration COLON ) =>
//				parameterDeclaration COLON! expression
//			|
//				forInit SEMI!   // initializer
//				forCond	SEMI!   // condition test
//				forIter         // updater
//			)			
//			RPAREN!
//			statement                     // statement to loop over
//
//	// While statement
//	|	'while'^ LPAREN! expression RPAREN! statement
//
//	// do-while statement
//	|	'do'^ statement 'while'! LPAREN! expression RPAREN! SEMI!
//
//	// get out of a loop (or switch)
//	|	'break'^ (IDENT)? SEMI!
//
//	// do next iteration of a loop
//	|	'continue'^ (IDENT)? SEMI!
//
//	// Return an expression
//	|	'return'^ (expression)? SEMI!
//
//	// switch/case statement
//	|	'switch'^ LPAREN! expression RPAREN! LCURLY!
//			( casesGroup )*
//		RCURLY!
//
//	// exception try-catch block
//	|	tryBlock
//
//	// throw an exception
//	|	'throw'^ expression SEMI!
//
//	// synchronize a statement
//	|	'synchronized'^ LPAREN! expression RPAREN! compoundStatement
//
//	// asserts (uncomment if you want 1.4 compatibility)
//	|	'assert'^ expression ( COLON! expression )? SEMI!
//
//	// empty statement
//	|	s=SEMI {$s.setType(EMPTY_STAT);}
//	;
statement
  // A list of statements in curly braces -- start a new scope!
  : compoundStatement -> compoundStatement
  // declarations are ambiguous with 'ID DOT' relative to expression
  // statements.  Must backtrack to be sure.  Could use a semantic
  // predicate to test symbol table to see what the type was coming
  // up, but that's pretty hard without a symbol table ;)
  | (declaration)=> declaration SEMI -> declaration

  // An expression statement.  This could be a method call,
  // assignment statement, or any other expression evaluated for
  // side-effects.
  | expression SEMI -> expression

  // class definition
  | a=annotations m=modifiers classDefinition[$m.tree, $a.tree]
    -> classDefinition

  // Attach a label to the front of a statement
  | IDENT COLON statement -> ^(LABELED_STAT IDENT statement)

  // If-else statement
  | 'if' LPAREN expression RPAREN ths=statement
    (options {k=1;}: ('else')=> 'else' els=statement)?
    -> ^('if' expression $ths $els?)

  // For statement
  | 'for'
      LPAREN
      (
        ( parameterDeclaration COLON ) =>
        parameterDeclaration COLON expression
      |
        forInit SEMI   // initializer
        forCond SEMI   // condition test
        forIter         // updater
      )     
      RPAREN
      statement                     // statement to loop over
   -> ^('for' parameterDeclaration? expression? forInit? forCond? forIter? statement)

  // While statement
  | 'while' LPAREN expression RPAREN statement -> ^('while' expression statement)

  // do-while statement
  | 'do' statement 'while' LPAREN expression RPAREN SEMI
    -> ^('do' statement expression)

  // get out of a loop (or switch)
  | 'break' IDENT? SEMI -> ^('break' IDENT?)

  // do next iteration of a loop
  | 'continue' IDENT? SEMI -> ^('continue' IDENT?)

  // Return an expression
  | 'return' expression? SEMI -> ^('return' expression?)

  // switch/case statement
  | 'switch' LPAREN expression RPAREN LCURLY
      casesGroup*
    RCURLY
    -> ^('switch' expression casesGroup*)

  // exception try-catch block
  | tryBlock -> tryBlock

  // throw an exception
  | 'throw' expression SEMI -> ^('throw' expression)

  // synchronize a statement
  | 'synchronized' LPAREN expression RPAREN compoundStatement
  -> ^('synchronized' expression compoundStatement)

  // asserts (uncomment if you want 1.4 compatibility)
  | 'assert' expression ( COLON expression )? SEMI
  -> ^('assert' expression expression?)

  // empty statement
  | SEMI  -> EMPTY_STAT
  ;

//casesGroup
//	:	(	// CONFLICT: to which case group do the statements bind?
//			//           ANTLR generates proper code: it groups the
//			//           many 'case'/'default' labels together then
//			//           follows them with the statements
//			options {
//				greedy = true;
//			}
//			:
//			aCase
//		)+
//		caseSList
//		{$casesGroup = $([CASE_GROUP, 'CASE_GROUP'], $casesGroup);}
//	;
casesGroup
  : ( // CONFLICT: to which case group do the statements bind?
      //           ANTLR generates proper code: it groups the
      //           many 'case'/'default' labels together then
      //           follows them with the statements
      options {
        greedy = true;
      }
      :
      aCase
    )+
    caseSList
    -> ^(CASE_GROUP aCase+ caseSList)
  ;

aCase
	:	('case'^ expression | 'default') COLON!
	;

//caseSList
//	:	(statement)*
//		{$caseSList = $($[SLIST,'SLIST'],$caseSList);}
//	;
caseSList
  : statement* -> ^(SLIST statement*)
  ;

// The initializer for a for loop
//forInit
//		// if it looks like a declaration, it is
//	:	(	(declaration)=> declaration
//		// otherwise it could be an expression list...
//		|	expressionList
//		)?
//		{$forInit = $($[FOR_INIT,'FOR_INIT'],$forInit);}
//	;
forInit
    // if it looks like a declaration, it is
  : ( (declaration)=> declaration
    // otherwise it could be an expression list...
    | expressionList
    )?
    -> ^(FOR_INIT declaration? expressionList?)
  ;

//forCond
//	:	(expression)?
//		{$forCond = $($[FOR_CONDITION,'FOR_CONDITION'],$forCond);}
//	;
	
forCond
  : expression? -> ^(FOR_CONDITION expression?)
  ;

//forIter
//	:	(expressionList)?
//		{$forIter = $($[FOR_ITERATOR,'FOR_ITERATOR'],$forIter);}
//	;
forIter
  : expressionList? -> ^(FOR_ITERATOR expressionList?)
  ;

// an exception handler try/catch block
tryBlock
	:	'try'^ (resourceDeclarations)? compoundStatement
		(handler)*
		( finallyClause )?
	;

// Java7 resourceStatement in try-block
// (This definition accepts more than what JDK7 allows but this is a reverse parser)
resourceDeclarations!
  :
  LPAREN! (declaration!)? (SEMI (declaration!)?)* RPAREN!
  ;
  
finallyClause
	:	'finally'^ compoundStatement
	;

// an exception handler
handler
	:	'catch'^ LPAREN! caughtExceptionDeclarations IDENT RPAREN! compoundStatement
	;
	
caughtExceptionDeclarations
  :	caughtExceptionDeclaration ( BOR! caughtExceptionDeclaration )*
  ;
  
caughtExceptionDeclaration! 
  : annotations parameterModifier annotations typeSpec[false]
  ;

// expressions
// Note that most of these expressions follow the pattern
//   thisLevelExpression :
//       nextHigherPrecedenceExpression
//           (OPERATOR nextHigherPrecedenceExpression)*
// which is a standard recursive definition for a parsing an expression.
// The operators in java have the following precedences:
//    lowest  (13)  = *= /= %= += -= <<= >>= >>>= &= ^= |=
//            (12)  ?:
//            (11)  ||
//            (10)  &&
//            ( 9)  |
//            ( 8)  ^
//            ( 7)  &
//            ( 6)  == !=
//            ( 5)  < <= > >=
//            ( 4)  << >>
//            ( 3)  +(binary) -(binary)
//            ( 2)  * / %
//            ( 1)  ++ -- +(unary) -(unary)  ~  !  (type)
//                  []   () (method call)  . (dot -- identifier qualification)
//                  new   ()  (explicit parenthesis)
//
// the last two are not usually on a precedence chart; I put them in
// to point out that new has a higher precedence than '.', so you
// can validy use
//     new Frame().show()
//
// Note that the above precedence levels map to the rules below...
// Once you have a precedence chart, writing the appropriate rules as below
//   is usually very straightfoward



// the mother of all expressions
//expression
//	:	assignmentExpression
//		{$expression = $($[EXPR,'EXPR'],$expression);}
//	;
expression
  : assignmentExpression -> ^(EXPR assignmentExpression)
  ;


// This is a list of expressions.
//expressionList
//	:	expression (COMMA! expression)*
//		{$expressionList = $($[ELIST,'ELIST'], expressionList);}
//	;
expressionList
  : expression (COMMA expression)*
    -> ^(ELIST expression+ )
  ;


// assignment expression (level 13)
assignmentExpression
	:	conditionalExpression (assignmentOperator assignmentExpression)?
	;

assignmentOperator
 : ASSIGN -> ASSIGN
 | PLUS_ASSIGN -> PLUS_ASSIGN
 | MINUS_ASSIGN -> MINUS_ASSIGN
 | STAR_ASSIGN -> STAR_ASSIGN
 | DIV_ASSIGN -> DIV_ASSIGN
 | MOD_ASSIGN -> MOD_ASSIGN
 | GT GT '=' -> SR_ASSIGN
 | GT GT GT '=' -> BSR_ASSIGN
 | LT LT '=' -> SL_ASSIGN
 | BAND_ASSIGN -> BAND_ASSIGN
 | BXOR_ASSIGN -> BXOR_ASSIGN
 | BOR_ASSIGN -> BOR_ASSIGN
 ;

// conditional test (level 12)
conditionalExpression
	:	logicalOrExpression
		( QUESTION^ assignmentExpression COLON! conditionalExpression )?
	;


// logical or (||)  (level 11)
logicalOrExpression
	:	logicalAndExpression (LOR^ logicalAndExpression)*
	;


// logical and (&&)  (level 10)
logicalAndExpression
	:	inclusiveOrExpression (LAND^ inclusiveOrExpression)*
	;


// bitwise or non-short-circuiting or (|)  (level 9)
inclusiveOrExpression
	:	exclusiveOrExpression (BOR^ exclusiveOrExpression)*
	;


// exclusive or (^)  (level 8)
exclusiveOrExpression
	:	andExpression (BXOR^ andExpression)*
	;


// bitwise or non-short-circuiting and (&)  (level 7)
andExpression
	:	equalityExpression (BAND^ equalityExpression)*
	;


// equality/inequality (==/!=) (level 6)
equalityExpression
	:	instanceOfExpression ((NOT_EQUAL^ | EQUAL^) instanceOfExpression)*
	;

// 'instanceof' Expression(level 5)
instanceOfExpression
  : relationalExpression ('instanceof'^ classTypeSpec[true])?
  ;

// boolean relational expressions (level 5bis)
relationalExpression
	:	additiveExpression (relationalOperator^	additiveExpression)*
	;
	
relationalOperator
  : LT     -> LT
  | LT LT  -> SL
  | LT '=' -> LE
  | GT     -> GT
  | GT GT  -> SR
  | GT '=' -> GE
  ;
// binary addition/subtraction (level 3)
additiveExpression
	:	multiplicativeExpression ((PLUS^ | MINUS^) multiplicativeExpression)*
	;


// multiplication/division/modulo (level 2)
multiplicativeExpression
	:	unaryExpression ((STAR^ | DIV^ | MOD^ ) unaryExpression)*
	;

unaryExpression
	:	INC^ unaryExpression
	|	DEC^ unaryExpression
	|	MINUS^ {$MINUS.setType(UNARY_MINUS);} unaryExpression
	|	PLUS^  {$PLUS.setType(UNARY_PLUS);} unaryExpression
	|	unaryExpressionNotPlusMinus
	;

//unaryExpressionNotPlusMinus
//	:	BNOT^ unaryExpression
//	|	LNOT^ unaryExpression
//
//	|	(	// subrule allows option to shut off warnings
//			options {
//				// '(int' ambig with postfixExpr due to lack of sequence
//				// info in linear approximate LL(k).  It's ok.  Shut up.
//				greedy = true;
//			}
//		:	// If typecast is built in type, must be numeric operand
//			// Also, no reason to backtrack if type keyword like int, float...
//			lpb=LPAREN^ {$lpb.setType(TYPECAST);} builtInTypeSpec[true] RPAREN!
//			unaryExpression
//
//			// Have to backtrack to see if operator follows.  If no operator
//			// follows, it's a typecast.  No semantic checking needed to parse.
//			// if it _looks_ like a cast, it _is_ a cast; else it's a '(expr)'
//		|	(LPAREN classTypeSpec[true] RPAREN unaryExpressionNotPlusMinus)=>
//			lp=LPAREN^ {$lp.setType(TYPECAST);} classTypeSpec[true] RPAREN!
//			unaryExpressionNotPlusMinus
//
//		|	postfixExpression
//		)
//	;
unaryExpressionNotPlusMinus
  : BNOT unaryExpression -> ^(BNOT unaryExpression)
  | LNOT unaryExpression -> ^(LNOT unaryExpression)

  | ( // subrule allows option to shut off warnings
      options {
        // '(int' ambig with postfixExpr due to lack of sequence
        // info in linear approximate LL(k).  It's ok.  Shut up.
        greedy = true;
      }
    : // If typecast is built in type, must be numeric operand
      // Also, no reason to backtrack if type keyword like int, float...
      LPAREN builtInTypeSpec[true] RPAREN unaryExpression
      -> ^(TYPECAST builtInTypeSpec unaryExpression)
      // Have to backtrack to see if operator follows.  If no operator
      // follows, it's a typecast.  No semantic checking needed to parse.
      // if it _looks_ like a cast, it _is_ a cast; else it's a '(expr)'
    | (LPAREN classTypeSpec[true] RPAREN unaryExpressionNotPlusMinus)=>
       LPAREN classTypeSpec[true] RPAREN unaryExpressionNotPlusMinus
      -> ^(TYPECAST classTypeSpec unaryExpressionNotPlusMinus)

    | postfixExpression -> postfixExpression
    )
  ;

// qualified names, array expressions, method invocation, post inc/dec
//postfixExpression
//	:
//    /*
//    'this'! lp1=LPAREN^ argList RPAREN!
//		{$lp1.setType(CTOR_CALL);}
//
//    |   'super'! lp2=LPAREN^ argList RPAREN!
//		{$lp2.setType(SUPER_CTOR_CALL);}
//    |
//    */
//        primaryExpression
//
//		(
//            /*
//            options {
//				// the use of postfixExpression in SUPER_CTOR_CALL adds DOT
//				// to the lookahead set, and gives loads of false non-det
//				// warnings.
//				// shut them off.
//				generateAmbigWarnings=false;
//			}
//		:	*/
//            DOT^ typeArguments IDENT
//			(	lp=LPAREN^ {$lp.setType(METHOD_CALL);}
//				argList
//				RPAREN!
//			)?
//		|	DOT^ 'this'
//
//		|	DOT^ 'super'
//            (   // (new Outer()).super()  (create enclosing instance)
//                lp3=LPAREN^ argList RPAREN!
//                {$lp3.setType(SUPER_CTOR_CALL);}
//			|   DOT^ IDENT
//                (	lps=LPAREN^ {$lps.setType(METHOD_CALL);}
//                    argList
//                    RPAREN!
//                )?
//            )
//		|	DOT^ newExpression
//		|	lb=LBRACK^ {$lb.setType(INDEX_OP);} expression RBRACK!
//		)*
//
//		(   // possibly add on a post-increment or post-decrement.
//            // allows INC/DEC on too much, but semantics can check
//			in=INC^ {$in.setType(POST_INC);}
//	 	|	de=DEC^ {$de.setType(POST_DEC);}
//		)?
// 	;
postfixExpression!
  :
    primaryExpression
    ( DOT typeArguments IDENT
       ( LPAREN argList RPAREN )?
    | DOT 'this'

    | DOT 'super'
            (   // (new Outer()).super()  (create enclosing instance)
                LPAREN argList RPAREN
                | DOT IDENT
                  ( LPAREN
                    argList
                    RPAREN
                  )?
            )
    | DOT newExpression
    | lb=LBRACK expression RBRACK
    )*

    (   // possibly add on a post-increment or post-decrement.
            // allows INC/DEC on too much, but semantics can check
      INC
    | DEC
    )?
  ;

// the basic element of an expression
primaryExpression
	:	identPrimary ( options {greedy=true;} : DOT^ 'class' )?
  |   constant
	|	'true'
	|	'false'
	|	'null'
  |   newExpression
	|	'this'
	|	'super'
	|	LPAREN! assignmentExpression RPAREN!
		// look for int.class and int[].class
	|	builtInType
		( lbt=LBRACK^ {$lbt.setType(ARRAY_DECLARATOR);} RBRACK! )*
		DOT^ 'class'
	;

/** Match a, a.b.c refs, a.b.c(...) refs, a.b.c[], a.b.c[].class,
 *  and a.b.c.class refs.  Also this(...) and super(...).  Match
 *  this or super.
 */
identPrimary
	:	IDENT
		(
            options {
				// .ident could match here or in postfixExpression.
				// We do want to match here.  Turn off warning.
				greedy=true;
			}
		:	DOT^ IDENT
		)*
		(
            options {
				// ARRAY_DECLARATOR here conflicts with INDEX_OP in
				// postfixExpression on LBRACK RBRACK.
				// We want to match [] here, so greedy.  This overcomes
                // limitation of linear approximate lookahead.
				greedy=true;
		    }
		:   ( lp=LPAREN^ {$lp.setType(METHOD_CALL);} argList RPAREN! )
		|	( options {greedy=true;} :
              lbc=LBRACK^ {$lbc.setType(ARRAY_DECLARATOR);} RBRACK!
            )+
		)?
    ;

/** object instantiation.
 *  Trees are built as illustrated by the following input/tree pairs:
 *
 *  new T()
 *
 *  new
 *   |
 *   T --  ELIST
 *           |
 *          arg1 -- arg2 -- .. -- argn
 *
 *  new int[]
 *
 *  new
 *   |
 *  int -- ARRAY_DECLARATOR
 *
 *  new int[] {1,2}
 *
 *  new
 *   |
 *  int -- ARRAY_DECLARATOR -- ARRAY_INIT
 *                                  |
 *                                EXPR -- EXPR
 *                                  |      |
 *                                  1      2
 *
 *  new int[3]
 *  new
 *   |
 *  int -- ARRAY_DECLARATOR
 *                |
 *              EXPR
 *                |
 *                3
 *
 *  new int[1][2]
 *
 *  new
 *   |
 *  int -- ARRAY_DECLARATOR
 *               |
 *         ARRAY_DECLARATOR -- EXPR
 *               |              |
 *             EXPR             1
 *               |
 *               2
 *
 */
newExpression
	:	'new'^ type
	    // JPE 1.5 : new de type generiques avec binding
	    (
	    	typeArguments
	    )?
	    // fin JPE
		(	LPAREN! argList RPAREN! (classBlock)?

			//java 1.1
			// Note: This will allow bad constructs like
			//    new int[4][][3] {exp,exp}.
			//    There needs to be a semantic check here...
			// to make sure:
			//   a) [ expr ] and [ ] are not mixed
			//   b) [ expr ] and an init are not used together

		|	newArrayDeclarator (arrayInitializer)?
		)
	;

argList
	:	(	expressionList -> expressionList
		|	/*nothing*/
			// {$argList = $[ELIST,'ELIST'];}
			-> ^(ELIST)
		)
	;

newArrayDeclarator
	:	(
			// CONFLICT:
			// newExpression is a primaryExpression which can be
			// followed by an array index reference.  This is ok,
			// as the generated code will stay in this loop as
			// long as it sees an LBRACK (proper behavior)
			options {
				greedy = true;
			}
		:
			lb=LBRACK^ {$lb.setType(ARRAY_DECLARATOR);}
				(expression)?
			RBRACK!
		)+
	;

constant
	:	NUM_LITERAL
	|	CHAR_LITERAL
	|	STRING_LITERAL
	;


//----------------------------------------------------------------------------
// The Java scanner
//----------------------------------------------------------------------------

// OPERATORS
QUESTION		:	'?'		;
LPAREN			:	'('		;
RPAREN			:	')'		;
LBRACK			:	'['		;
RBRACK			:	']'		;
LCURLY			:	'{'		;
RCURLY			:	'}'		;
COLON			:	':'		;
COMMA			:	','		;
DOT			:	'.'		;
ASSIGN			:	'='		;
EQUAL			:	'=='	;
LNOT			:	'!'		;
BNOT			:	'~'		;
NOT_EQUAL		:	'!='	;
DIV				:	'/'		;
DIV_ASSIGN		:	'/='	;
PLUS			:	'+'		;
PLUS_ASSIGN		:	'+='	;
INC				:	'++'	;
MINUS			:	'-'		;
MINUS_ASSIGN	:	'-='	;
DEC				:	'--'	;
STAR			:	'*'		;
STAR_ASSIGN		:	'*='	;
MOD				:	'%'		;
MOD_ASSIGN		:	'%='	;
GT				:	'>'		;
LT				:	'<'		;
BXOR			:	'^'		;
BXOR_ASSIGN		:	'^='	;
BOR				:	'|'		;
BOR_ASSIGN		:	'|='	;
LOR				:	'||'	;
BAND			:	'&'		;
BAND_ASSIGN		:	'&='	;
LAND			:	'&&'	;
SEMI			:	';'		;
AT 	      :   '@'     ;
ELLIPSIS	:	'...'	;


// Whitespace -- ignored
WS	:	(	' '
		|	'\t'
		|	'\f'
			// handle newlines
		|	(	options {greedy = true;}
			:	'\r\n'  // Evil DOS
			|	'\r'    // Macintosh
			|	'\n'    // Unix (the right way)
			)
		)+
		{ $channel = HIDDEN; }
	;

COMMENT
        @init{
            boolean isJavaDoc = false;
        }
    :   '/*'
            {
                if((char)input.LA(1) == '*'){
                    isJavaDoc = true;
                }
            }
        (options {greedy=false;} : . )* 
        '*/'
            {
                if(isJavaDoc==true) {
                    $channel=HIDDEN;
                } else {
                    skip();
                }
            }
    ;

LINE_COMMENT
    :   '//' ~('\n'|'\r')*  ('\r\n' | '\r' | '\n') 
                {
                    skip();
                }
    |   '//' ~('\n'|'\r')*     // a line comment could appear at the end of the file without CR/LF
            {
                skip();
            }
    ;   


// character literals
CHAR_LITERAL
	:	'\'' ( ESC | ~'\'' ) '\''
	;

// string literals
STRING_LITERAL
  : '"' (ESC|~('"'|'\\'))* '"'
  ;

// escape sequence 
// There are various ambiguities hushed in this rule.  The optional
// '0'...'9' digit matches should be matched here rather than letting
// them go back to STRING_LITERAL to be matched.  ANTLR does the
// right thing by matching immediately; hence, it's ok to shut off
// the FOLLOW ambig warnings.
fragment
ESC
	:	'\\'
		(	'n'
		|	'r'
		|	't'
		|	'b'
		|	'f'
		|	'\''
		|	'"'
		|	'\\'
		|	('u')+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
		|	'0'..'3'
			(
				options {
					greedy = true;
				}
			:	'0'..'7'
				(
					options {
						greedy = true;
					}
				:	'0'..'7'
				)?
			)?
		|	'4'..'7'
			(
				options {
					greedy = true;
				}
			:	'0'..'7'
			)?
		)
	;

// binary digit
fragment
BIN_DIGIT
  : '0'..'1'
  ;
fragment BIN_NUM
  : BIN_DIGIT (options { greedy=true; } : BIN_DIGIT | '_')*
  ;

// decimal digit
fragment
DEC_DIGIT
  : '0'..'9'
  ;
fragment
DEC_NUM
  : DEC_DIGIT (options { greedy=true; } : DEC_DIGIT | '_')*
  ;

// hexadecimal digit (again, note it's fragment!)
fragment
HEX_DIGIT
	:	('0'..'9'|'A'..'F'|'a'..'f')
	;
fragment
HEX_NUM
  : HEX_DIGIT (options { greedy=true; } : HEX_DIGIT | '_' )*
  ;

// an identifier
IDENT
	:
		('a'..'z'|'A'..'Z'|'\u00C0'..'\u00D6'|'\u00D8'..'\u00F6'|'\u00F8'..'\u00FF'|'_'|'$') ('a'..'z'|'A'..'Z'|'\u00C0'..'\u00D6'|'\u00D8'..'\u00F6'|'\u00F8'..'\u00FF'|'_'|'0'..'9'|'$')*
	;


// a numeric literal
NUM_LITERAL
  : '.' DEC_NUM EXPONENT? FLOAT_SUFFIX?    // Note DEC_NUM behind '.' is mandatory
  | ('0x'|'0X') HEX_NUM* ( LONG_SUFFIX | '.' HEX_NUM* ('p'|'P') ('+'|'-')? DEC_NUM FLOAT_SUFFIX? )?
  | ('0b'|'0B') BIN_NUM         
  | DEC_NUM DEC_END?
  ;
  
fragment
DEC_END
  : LONG_SUFFIX 
  | '.' DEC_NUM? EXPONENT? FLOAT_SUFFIX?   // Note DEC_NUM behind '.' is optionnal 
  | EXPONENT FLOAT_SUFFIX?
  | FLOAT_SUFFIX
  ;

fragment
EXPONENT
	:	('e'|'E') ('+'|'-')? ('0'..'9' )+
	;

fragment
FLOAT_SUFFIX
	:	'f'|'F'|'d'|'D'
	;
	
fragment
LONG_SUFFIX
  : 'l' | 'L'
  ;